welcome to iREPL
ok, loaded 20 functions from data/libs/prelude.icicle
ok, loaded test/cli/repl/data.psv, 13 rows
> -- Show everything
> ok, core-simp is now on
ok, flatten is now on
> > -- A rather complicated feature to convert to Avalanche
> - Flattened:
gen$date = DATE
{
  init acc$c$conv$13$simp$4@{Mutable Bool} = True@{Bool};
  init acc$c$conv$13$simp$5@{Mutable Error} = ExceptTombstone@{Error};
  init acc$c$conv$13$simp$6@{Mutable Int} = 0@{Int};
  init acc$conv$30@{Mutable Buf (Sum Error Int)} = Buf 3 []@{Buf (Sum Error Int)};
  load_resumable@{Bool} acc$c$conv$13$simp$4;
  load_resumable@{Error} acc$c$conv$13$simp$5;
  load_resumable@{Int} acc$c$conv$13$simp$6;
  load_resumable@{Buf (Sum Error Int)} acc$conv$30;
  for_facts (gen$fact$simp$47$simp$49@{Bool},
             gen$fact$simp$47$simp$50@{Error},
             gen$fact$simp$47$simp$51@{Int},
             gen$fact$simp$48@{DateTime}) in new {
    read@{Mutable Buf (Sum Error Int)} acc$conv$30 = acc$conv$30;
    let simp$54 = Sum_pack#@{Error Int}
                  gen$fact$simp$47$simp$49
                  gen$fact$simp$47$simp$50
                  gen$fact$simp$47$simp$51;
    let flat$0 = Buf_push#@{(Sum Error Int)}
                 acc$conv$30 simp$54;
    write acc$conv$30 = flat$0;
    init flat$1$simp$7@{Mutable Bool} = False@{Bool};
    init flat$1$simp$9@{Mutable Bool} = False@{Bool};
    if (gen$fact$simp$47$simp$49) {
      let simp$1 = gt#@{Int}
                   gen$fact$simp$47$simp$51 (10@{Int});
      write flat$1$simp$7 = True@{Bool};
      write flat$1$simp$9 = simp$1;
    } else {
      write flat$1$simp$7 = False@{Bool};
      write flat$1$simp$9 = False@{Bool};
    }
    read@{Mutable Bool} flat$1$simp$10 = flat$1$simp$7;
    read@{Mutable Bool} flat$1$simp$12 = flat$1$simp$9;
    init flat$2@{Mutable Bool} = False@{Bool};
    if (flat$1$simp$10) {
      write flat$2 = flat$1$simp$12;
    } 
     else {
      write flat$2 = True@{Bool};
    } 
    
    read@{Mutable Bool} flat$2 = flat$2;
    if (flat$2) {
      read@{Mutable Bool} acc$c$conv$13$simp$13 = acc$c$conv$13$simp$4;
      read@{Mutable Error} acc$c$conv$13$simp$14 = acc$c$conv$13$simp$5;
      read@{Mutable Int} acc$c$conv$13$simp$15 = acc$c$conv$13$simp$6;
      init flat$3$simp$16@{Mutable Bool} = False@{Bool};
      init flat$3$simp$17@{Mutable Error} = ExceptTombstone@{Error};
      init flat$3$simp$18@{Mutable Int} = 0@{Int};
      if (gen$fact$simp$47$simp$49) {
        init flat$6$simp$19@{Mutable Bool} = False@{Bool};
        init flat$6$simp$20@{Mutable Error} = ExceptTombstone@{Error};
        init flat$6$simp$21@{Mutable Int} = 0@{Int};
        if (acc$c$conv$13$simp$13) {
          let simp$3 = add#@{Int}
                       acc$c$conv$13$simp$15 (1@{Int});
          write flat$6$simp$19 = True@{Bool};
          write flat$6$simp$20 = ExceptTombstone@{Error};
          write flat$6$simp$21 = simp$3;
        } else {
          write flat$6$simp$19 = False@{Bool};
          write flat$6$simp$20 = acc$c$conv$13$simp$14;
          write flat$6$simp$21 = 0@{Int};
        }
        read@{Mutable Bool} flat$6$simp$22 = flat$6$simp$19;
        read@{Mutable Error} flat$6$simp$23 = flat$6$simp$20;
        read@{Mutable Int} flat$6$simp$24 = flat$6$simp$21;
        init flat$7$simp$25@{Mutable Bool} = False@{Bool};
        init flat$7$simp$26@{Mutable Error} = ExceptTombstone@{Error};
        init flat$7$simp$27@{Mutable Int} = 0@{Int};
        if (flat$6$simp$22) {
          write flat$7$simp$25 = True@{Bool};
          write flat$7$simp$26 = ExceptTombstone@{Error};
          write flat$7$simp$27 = flat$6$simp$24;
        } else {
          write flat$7$simp$25 = False@{Bool};
          write flat$7$simp$26 = flat$6$simp$23;
          write flat$7$simp$27 = 0@{Int};
        }
        read@{Mutable Bool} flat$7$simp$28 = flat$7$simp$25;
        read@{Mutable Error} flat$7$simp$29 = flat$7$simp$26;
        read@{Mutable Int} flat$7$simp$30 = flat$7$simp$27;
        write flat$3$simp$16 = flat$7$simp$28;
        write flat$3$simp$17 = flat$7$simp$29;
        write flat$3$simp$18 = flat$7$simp$30;
      } else {
        write flat$3$simp$16 = False@{Bool};
        write flat$3$simp$17 = gen$fact$simp$47$simp$50;
        write flat$3$simp$18 = 0@{Int};
      }
      read@{Mutable Bool} flat$3$simp$31 = flat$3$simp$16;
      read@{Mutable Error} flat$3$simp$32 = flat$3$simp$17;
      read@{Mutable Int} flat$3$simp$33 = flat$3$simp$18;
      write acc$c$conv$13$simp$4 = flat$3$simp$31;
      write acc$c$conv$13$simp$5 = flat$3$simp$32;
      write acc$c$conv$13$simp$6 = flat$3$simp$33;
    }
  }
  save_resumable@{Bool} acc$c$conv$13$simp$4;
  save_resumable@{Error} acc$c$conv$13$simp$5;
  save_resumable@{Int} acc$c$conv$13$simp$6;
  save_resumable@{Buf (Sum Error Int)} acc$conv$30;
  read@{Mutable Bool} c$conv$13$simp$34 = acc$c$conv$13$simp$4;
  read@{Mutable Error} c$conv$13$simp$35 = acc$c$conv$13$simp$5;
  read@{Mutable Int} c$conv$13$simp$36 = acc$c$conv$13$simp$6;
  read@{Mutable Buf (Sum Error Int)} conv$30 = acc$conv$30;
  init flat$16$simp$37@{Mutable Bool} = False@{Bool};
  init flat$16$simp$38@{Mutable Error} = ExceptTombstone@{Error};
  init flat$16$simp$39$simp$40@{Mutable Int} = 0@{Int};
  init flat$16$simp$39$simp$41@{Mutable Array (Sum Error Int)} = []@{Array (Sum Error Int)};
  if (c$conv$13$simp$34) {
    let flat$19 = Buf_read#@{(Sum Error Int)}
                  conv$30;
    write flat$16$simp$37 = True@{Bool};
    write flat$16$simp$38 = ExceptTombstone@{Error};
    write flat$16$simp$39$simp$40 = c$conv$13$simp$36;
    write flat$16$simp$39$simp$41 = flat$19;
  } else {
    write flat$16$simp$37 = False@{Bool};
    write flat$16$simp$38 = c$conv$13$simp$35;
    write flat$16$simp$39$simp$40 = 0@{Int};
    write flat$16$simp$39$simp$41 = []@{Array (Sum Error Int)};
  }
  read@{Mutable Bool} flat$16$simp$42 = flat$16$simp$37;
  read@{Mutable Error} flat$16$simp$43 = flat$16$simp$38;
  read@{Mutable Int} flat$16$simp$44$simp$45 = flat$16$simp$39$simp$40;
  read@{Mutable Array (Sum Error Int)} flat$16$simp$44$simp$46 = flat$16$simp$39$simp$41;
  output@{(Sum Error (Int, Array (Sum Error Int)))} repl (flat$16$simp$42@{Bool},
               flat$16$simp$43@{Error},
               flat$16$simp$44$simp$45@{Int},
               flat$16$simp$44$simp$46@{Array (Sum Error Int)});
}

- Core evaluation:
[homer, (5,[300,400,500])
,marge, (1,[0,10,20])]

> > -- Something involves the abstract buffer type
> - Flattened:
gen$date = DATE
{
  init acc$conv$2@{Mutable Map DateTime (Buf ((Sum Error Int), DateTime))} = Map []@{Map DateTime (Buf ((Sum Error Int), DateTime))};
  load_resumable@{Map DateTime (Buf ((Sum Error Int), DateTime))} acc$conv$2;
  for_facts (gen$fact$simp$67$simp$69@{Bool},
             gen$fact$simp$67$simp$70@{Error},
             gen$fact$simp$67$simp$71@{Int},
             gen$fact$simp$68@{DateTime}) in new {
    read@{Mutable Map DateTime (Buf ((Sum Error Int), DateTime))} acc$conv$2 = acc$conv$2;
    let simp$74 = Sum_pack#@{Error Int}
                  gen$fact$simp$67$simp$69
                  gen$fact$simp$67$simp$70
                  gen$fact$simp$67$simp$71;
    let simp$75 = pair#@{(Sum Error Int) DateTime} simp$74
                  gen$fact$simp$68;
    let flat$0 = Buf_push#@{((Sum Error Int), DateTime)}
                 (Buf 2 []@{Buf ((Sum Error Int), DateTime)}) simp$75;
    let flat$1 = Map_lookup#@{DateTime Buf ((Sum Error Int), DateTime)}
                 acc$conv$2 gen$fact$simp$68;
    if (Option_isSome# [Buf ((Sum Error Int), DateTime)]
        flat$1) {
      let flat$2 = unsafe_Option_get#@{Buf ((Sum Error Int), DateTime)}
                   flat$1;
      let flat$3 = Buf_push#@{((Sum Error Int), DateTime)} flat$2
                   simp$75;
      let flat$4 = Map_put#@{DateTime Buf ((Sum Error Int), DateTime)} acc$conv$2
                   gen$fact$simp$68 flat$3;
      write acc$conv$2 = flat$4;
    } else {
      let flat$5 = Map_put#@{DateTime Buf ((Sum Error Int), DateTime)}
                   acc$conv$2 gen$fact$simp$68
                   flat$0;
      write acc$conv$2 = flat$5;
    }
  }
  save_resumable@{Map DateTime (Buf ((Sum Error Int), DateTime))} acc$conv$2;
  read@{Mutable Map DateTime (Buf ((Sum Error Int), DateTime))} conv$2 = acc$conv$2;
  init flat$6$simp$4@{Mutable Bool} = True@{Bool};
  init flat$6$simp$5@{Mutable Error} = ExceptTombstone@{Error};
  init flat$6$simp$6@{Mutable Map DateTime Int} = Map []@{Map DateTime Int};
  foreach (flat$7 in 0@{Int}..Map_length#@{DateTime Buf ((Sum Error Int), DateTime)}
                        conv$2) {
    read@{Mutable Bool} flat$6$simp$7 = flat$6$simp$4;
    read@{Mutable Error} flat$6$simp$8 = flat$6$simp$5;
    read@{Mutable Map DateTime Int} flat$6$simp$9 = flat$6$simp$6;
    let flat$8 = unsafe_Map_index#@{DateTime Buf ((Sum Error Int), DateTime)}
                 conv$2 flat$7;
    let flat$9 = fst#@{DateTime Buf ((Sum Error Int), DateTime)} flat$8;
    let flat$10 = snd#@{DateTime Buf ((Sum Error Int), DateTime)} flat$8;
    init flat$11$simp$10@{Mutable Bool} = False@{Bool};
    init flat$11$simp$11@{Mutable Error} = ExceptTombstone@{Error};
    init flat$11$simp$12@{Mutable Map DateTime Int} = Map []@{Map DateTime Int};
    if (flat$6$simp$7) {
      let flat$14 = Buf_read#@{((Sum Error Int), DateTime)}
                    flat$10;
      init flat$15$simp$14$simp$18$simp$20@{Mutable Bool} = True@{Bool};
      init flat$15$simp$14$simp$18$simp$21@{Mutable Error} = ExceptTombstone@{Error};
      init flat$15$simp$14$simp$18$simp$22@{Mutable Int} = 0@{Int};
      foreach (flat$23 in 0@{Int}..Array_length#@{((Sum Error Int), DateTime)}
                             flat$14) {
        read@{Mutable Bool} flat$15$simp$24$simp$28$simp$30 = flat$15$simp$14$simp$18$simp$20;
        read@{Mutable Error} flat$15$simp$24$simp$28$simp$31 = flat$15$simp$14$simp$18$simp$21;
        read@{Mutable Int} flat$15$simp$24$simp$28$simp$32 = flat$15$simp$14$simp$18$simp$22;
        let flat$24 = unsafe_Array_index#@{((Sum Error Int), DateTime)}
                      flat$14 flat$23;
        let v$inline$0$conv$13 = fst#@{(Sum Error Int) DateTime}
                                 flat$24;
        init flat$25$simp$33@{Mutable Bool} = False@{Bool};
        init flat$25$simp$34@{Mutable Error} = ExceptTombstone@{Error};
        init flat$25$simp$35@{Mutable Int} = 0@{Int};
        if (Sum_isRight#@{Error Int}
            v$inline$0$conv$13) {
          let flat$27 = unsafe_Sum_right#@{Error Int}
                        v$inline$0$conv$13;
          init flat$28$simp$36@{Mutable Bool} = False@{Bool};
          init flat$28$simp$37@{Mutable Error} = ExceptTombstone@{Error};
          init flat$28$simp$38@{Mutable Int} = 0@{Int};
          if (flat$15$simp$24$simp$28$simp$30) {
            let simp$1 = add#@{Int} flat$27
                         flat$15$simp$24$simp$28$simp$32;
            write flat$28$simp$36 = True@{Bool};
            write flat$28$simp$37 = ExceptTombstone@{Error};
            write flat$28$simp$38 = simp$1;
          } else {
            write flat$28$simp$36 = False@{Bool};
            write flat$28$simp$37 = flat$15$simp$24$simp$28$simp$31;
            write flat$28$simp$38 = 0@{Int};
          }
          read@{Mutable Bool} flat$28$simp$39 = flat$28$simp$36;
          read@{Mutable Error} flat$28$simp$40 = flat$28$simp$37;
          read@{Mutable Int} flat$28$simp$41 = flat$28$simp$38;
          write flat$25$simp$33 = flat$28$simp$39;
          write flat$25$simp$34 = flat$28$simp$40;
          write flat$25$simp$35 = flat$28$simp$41;
        } else {
          let flat$26 = unsafe_Sum_left#@{Error Int}
                        v$inline$0$conv$13;
          write flat$25$simp$33 = False@{Bool};
          write flat$25$simp$34 = flat$26;
          write flat$25$simp$35 = 0@{Int};
        }
        read@{Mutable Bool} flat$25$simp$42 = flat$25$simp$33;
        read@{Mutable Error} flat$25$simp$43 = flat$25$simp$34;
        read@{Mutable Int} flat$25$simp$44 = flat$25$simp$35;
        write flat$15$simp$14$simp$18$simp$20 = flat$25$simp$42;
        write flat$15$simp$14$simp$18$simp$21 = flat$25$simp$43;
        write flat$15$simp$14$simp$18$simp$22 = flat$25$simp$44;
      }
      read@{Mutable Bool} flat$15$simp$46$simp$50$simp$52 = flat$15$simp$14$simp$18$simp$20;
      read@{Mutable Error} flat$15$simp$46$simp$50$simp$53 = flat$15$simp$14$simp$18$simp$21;
      read@{Mutable Int} flat$15$simp$46$simp$50$simp$54 = flat$15$simp$14$simp$18$simp$22;
      init flat$16$simp$55@{Mutable Bool} = False@{Bool};
      init flat$16$simp$56@{Mutable Error} = ExceptTombstone@{Error};
      init flat$16$simp$57@{Mutable Map DateTime Int} = Map []@{Map DateTime Int};
      if (flat$15$simp$46$simp$50$simp$52) {
        let flat$19 = Map_lookup#@{DateTime Int}
                      flat$6$simp$9 flat$9;
        if (Option_isSome# [Int]
            flat$19) {
          let flat$20 = unsafe_Option_get#@{Int}
                        flat$19;
          let flat$21 = Map_put#@{DateTime Int}
                        flat$6$simp$9 flat$9 flat$20;
          write flat$16$simp$55 = True@{Bool};
          write flat$16$simp$56 = ExceptTombstone@{Error};
          write flat$16$simp$57 = flat$21;
        } else {
          let flat$22 = Map_put#@{DateTime Int}
                        flat$6$simp$9 flat$9
                        flat$15$simp$46$simp$50$simp$54;
          write flat$16$simp$55 = True@{Bool};
          write flat$16$simp$56 = ExceptTombstone@{Error};
          write flat$16$simp$57 = flat$22;
        }
      } else {
        write flat$16$simp$55 = False@{Bool};
        write flat$16$simp$56 = flat$15$simp$46$simp$50$simp$53;
        write flat$16$simp$57 = Map []@{Map DateTime Int};
      }
      read@{Mutable Bool} flat$16$simp$58 = flat$16$simp$55;
      read@{Mutable Error} flat$16$simp$59 = flat$16$simp$56;
      read@{Mutable Map DateTime Int} flat$16$simp$60 = flat$16$simp$57;
      write flat$11$simp$10 = flat$16$simp$58;
      write flat$11$simp$11 = flat$16$simp$59;
      write flat$11$simp$12 = flat$16$simp$60;
    } else {
      write flat$11$simp$10 = False@{Bool};
      write flat$11$simp$11 = flat$6$simp$8;
      write flat$11$simp$12 = Map []@{Map DateTime Int};
    }
    read@{Mutable Bool} flat$11$simp$61 = flat$11$simp$10;
    read@{Mutable Error} flat$11$simp$62 = flat$11$simp$11;
    read@{Mutable Map DateTime Int} flat$11$simp$63 = flat$11$simp$12;
    write flat$6$simp$4 = flat$11$simp$61;
    write flat$6$simp$5 = flat$11$simp$62;
    write flat$6$simp$6 = flat$11$simp$63;
  }
  read@{Mutable Bool} flat$6$simp$64 = flat$6$simp$4;
  read@{Mutable Error} flat$6$simp$65 = flat$6$simp$5;
  read@{Mutable Map DateTime Int} flat$6$simp$66 = flat$6$simp$6;
  output@{(Sum Error (Map DateTime Int))} repl (flat$6$simp$64@{Bool},
               flat$6$simp$65@{Error},
               flat$6$simp$66@{Map DateTime Int});
}

- Core evaluation:
[homer, [(1989-12-17,100)
        ,(1990-01-01,200)
        ,(1994-01-01,300)
        ,(1999-01-01,400)
        ,(2010-01-01,500)]
,marge, [(1989-12-17,30)]]

> > > 