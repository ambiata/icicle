welcome to iREPL
ok, loaded 20 functions from data/libs/prelude.icicle
ok, loaded test/cli/repl/data.psv, 13 rows
> -- Show everything
> ok, core-simp is now on
ok, flatten is now on
> > -- A rather complicated feature to convert to Avalanche
> - Flattened:
gen$date = DATE
{
  init acc$c$conv$13$simp$4@{Bool} = True@{Bool};
  init acc$c$conv$13$simp$5@{Error} = ExceptTombstone@{Error};
  init acc$c$conv$13$simp$6@{Int} = 0@{Int};
  init acc$conv$30@{Buf (Sum Error Int)} = Buf 3 []@{Buf (Sum Error Int)};
  load_resumable@{Bool} acc$c$conv$13$simp$4;
  load_resumable@{Error} acc$c$conv$13$simp$5;
  load_resumable@{Int} acc$c$conv$13$simp$6;
  load_resumable@{Buf (Sum Error Int)} acc$conv$30;
  for_facts (gen$fact$simp$50$simp$52@{Bool},
             gen$fact$simp$50$simp$53@{Error},
             gen$fact$simp$50$simp$54@{Int},
             gen$fact$simp$51@{DateTime}) in new {
    read@{Buf (Sum Error Int)} acc$conv$30 = acc$conv$30;
    let simp$57 = Sum_pack#@{Error, Int}
                  gen$fact$simp$50$simp$52
                  gen$fact$simp$50$simp$53
                  gen$fact$simp$50$simp$54;
    let flat$0 = Buf_push#@{(Sum Error Int)}
                 acc$conv$30 simp$57;
    write acc$conv$30 = flat$0;
    init flat$1$simp$7@{Bool} = False@{Bool};
    init flat$1$simp$9@{Bool} = False@{Bool};
    if (gen$fact$simp$50$simp$52) {
      write flat$1$simp$7 = True@{Bool};
      let simp$67 = gt#@{Int}
                    gen$fact$simp$50$simp$54 (10@{Int});
      write flat$1$simp$9 = simp$67;
    } else {
      write flat$1$simp$7 = False@{Bool};
      write flat$1$simp$9 = False@{Bool};
    }
    read@{Bool} flat$1$simp$10 = flat$1$simp$7;
    read@{Bool} flat$1$simp$12 = flat$1$simp$9;
    init flat$2@{Bool} = False@{Bool};
    if (flat$1$simp$10) {
      write flat$2 = flat$1$simp$12;
    } 
     else {
      write flat$2 = True@{Bool};
    } 
    
    read@{Bool} flat$2 = flat$2;
    if (flat$2) {
      read@{Bool} acc$c$conv$13$simp$13 = acc$c$conv$13$simp$4;
      read@{Error} acc$c$conv$13$simp$14 = acc$c$conv$13$simp$5;
      read@{Int} acc$c$conv$13$simp$15 = acc$c$conv$13$simp$6;
      init flat$3$simp$16@{Bool} = False@{Bool};
      init flat$3$simp$17@{Error} = ExceptTombstone@{Error};
      init flat$3$simp$18@{Int} = 0@{Int};
      if (gen$fact$simp$50$simp$52) {
        init flat$6$simp$19@{Bool} = False@{Bool};
        init flat$6$simp$20@{Error} = ExceptTombstone@{Error};
        init flat$6$simp$21@{Int} = 0@{Int};
        if (acc$c$conv$13$simp$13) {
          write flat$6$simp$19 = True@{Bool};
          let simp$88 = add#@{Int}
                        acc$c$conv$13$simp$15 (1@{Int});
          write flat$6$simp$20 = ExceptTombstone@{Error};
          write flat$6$simp$21 = simp$88;
        } else {
          write flat$6$simp$19 = False@{Bool};
          write flat$6$simp$20 = acc$c$conv$13$simp$14;
          write flat$6$simp$21 = 0@{Int};
        }
        read@{Bool} flat$6$simp$22 = flat$6$simp$19;
        read@{Error} flat$6$simp$23 = flat$6$simp$20;
        read@{Int} flat$6$simp$24 = flat$6$simp$21;
        init flat$7$simp$25@{Bool} = False@{Bool};
        init flat$7$simp$26@{Error} = ExceptTombstone@{Error};
        init flat$7$simp$27@{Int} = 0@{Int};
        if (flat$6$simp$22) {
          write flat$7$simp$25 = True@{Bool};
          write flat$7$simp$26 = ExceptTombstone@{Error};
          write flat$7$simp$27 = flat$6$simp$24;
        } else {
          write flat$7$simp$25 = False@{Bool};
          write flat$7$simp$26 = flat$6$simp$23;
          write flat$7$simp$27 = 0@{Int};
        }
        read@{Bool} flat$7$simp$28 = flat$7$simp$25;
        read@{Error} flat$7$simp$29 = flat$7$simp$26;
        read@{Int} flat$7$simp$30 = flat$7$simp$27;
        write flat$3$simp$16 = flat$7$simp$28;
        write flat$3$simp$17 = flat$7$simp$29;
        write flat$3$simp$18 = flat$7$simp$30;
      } else {
        write flat$3$simp$16 = False@{Bool};
        write flat$3$simp$17 = gen$fact$simp$50$simp$53;
        write flat$3$simp$18 = 0@{Int};
      }
      read@{Bool} flat$3$simp$31 = flat$3$simp$16;
      read@{Error} flat$3$simp$32 = flat$3$simp$17;
      read@{Int} flat$3$simp$33 = flat$3$simp$18;
      write acc$c$conv$13$simp$4 = flat$3$simp$31;
      write acc$c$conv$13$simp$5 = flat$3$simp$32;
      write acc$c$conv$13$simp$6 = flat$3$simp$33;
    }
  }
  save_resumable@{Bool} acc$c$conv$13$simp$4;
  save_resumable@{Error} acc$c$conv$13$simp$5;
  save_resumable@{Int} acc$c$conv$13$simp$6;
  save_resumable@{Buf (Sum Error Int)} acc$conv$30;
  read@{Bool} c$conv$13$simp$34 = acc$c$conv$13$simp$4;
  read@{Error} c$conv$13$simp$35 = acc$c$conv$13$simp$5;
  read@{Int} c$conv$13$simp$36 = acc$c$conv$13$simp$6;
  read@{Buf (Sum Error Int)} conv$30 = acc$conv$30;
  init flat$16$simp$37@{Bool} = False@{Bool};
  init flat$16$simp$38@{Error} = ExceptTombstone@{Error};
  init flat$16$simp$39$simp$40@{Int} = 0@{Int};
  init flat$16$simp$39$simp$41@{Array (Sum Error Int)} = []@{Array (Sum Error Int)};
  if (c$conv$13$simp$34) {
    let flat$19 = Buf_read#@{(Sum Error Int)}
                  conv$30;
    write flat$16$simp$37 = True@{Bool};
    write flat$16$simp$38 = ExceptTombstone@{Error};
    write flat$16$simp$39$simp$40 = c$conv$13$simp$36;
    write flat$16$simp$39$simp$41 = flat$19;
  } else {
    write flat$16$simp$37 = False@{Bool};
    write flat$16$simp$38 = c$conv$13$simp$35;
    write flat$16$simp$39$simp$40 = 0@{Int};
    write flat$16$simp$39$simp$41 = []@{Array (Sum Error Int)};
  }
  read@{Bool} flat$16$simp$42 = flat$16$simp$37;
  read@{Error} flat$16$simp$43 = flat$16$simp$38;
  read@{Int} flat$16$simp$44$simp$45 = flat$16$simp$39$simp$40;
  read@{Array (Sum Error Int)} flat$16$simp$44$simp$46 = flat$16$simp$39$simp$41;
  output@{(Sum Error (Int, Array (Sum Error Int)))} repl (flat$16$simp$42@{Bool},
               flat$16$simp$43@{Error},
               flat$16$simp$44$simp$45@{Int},
               flat$16$simp$44$simp$46@{Array (Sum Error Int)});
}

- Core evaluation:
[homer, (5,[300,400,500])
,marge, (1,[0,10,20])]

> > -- Something involves the abstract buffer type
> - Flattened:
gen$date = DATE
{
  init acc$conv$2@{Map DateTime (Buf ((Sum Error Int), DateTime))} = Map []@{Map DateTime (Buf ((Sum Error Int), DateTime))};
  load_resumable@{Map DateTime (Buf ((Sum Error Int), DateTime))} acc$conv$2;
  for_facts (gen$fact$simp$70$simp$72@{Bool},
             gen$fact$simp$70$simp$73@{Error},
             gen$fact$simp$70$simp$74@{Int},
             gen$fact$simp$71@{DateTime}) in new {
    read@{Map DateTime (Buf ((Sum Error Int), DateTime))} acc$conv$2 = acc$conv$2;
    let simp$77 = Sum_pack#@{Error, Int}
                  gen$fact$simp$70$simp$72
                  gen$fact$simp$70$simp$73
                  gen$fact$simp$70$simp$74;
    let simp$78 = pair#@{(Sum Error Int) DateTime} simp$77
                  gen$fact$simp$71;
    let flat$0 = Buf_push#@{((Sum Error Int), DateTime)}
                 (Buf 2 []@{Buf ((Sum Error Int), DateTime)}) simp$78;
    init flat$4@{Map DateTime (Buf ((Sum Error Int), DateTime))} = acc$conv$2;
    let flat$1 = Map_lookup#@{DateTime, Buf ((Sum Error Int), DateTime)}
                 acc$conv$2 gen$fact$simp$71;
    if (Option_isSome# [Buf ((Sum Error Int), DateTime)]
        flat$1) {
      let flat$3 = unsafe_Option_get#@{Buf ((Sum Error Int), DateTime)}
                   flat$1;
      let flat$6 = Buf_push#@{((Sum Error Int), DateTime)} flat$3
                   simp$78;
      write flat$4 = Map_put#@{DateTime, Buf ((Sum Error Int), DateTime)}
                     acc$conv$2 gen$fact$simp$71
                     flat$6;
    } else {
      write flat$4 = Map_put#@{DateTime, Buf ((Sum Error Int), DateTime)}
                     acc$conv$2 gen$fact$simp$71
                     flat$0;
    } 
    
    read@{Map DateTime (Buf ((Sum Error Int), DateTime))} flat$5 = flat$4;
    write acc$conv$2 = flat$5;
  }
  save_resumable@{Map DateTime (Buf ((Sum Error Int), DateTime))} acc$conv$2;
  read@{Map DateTime (Buf ((Sum Error Int), DateTime))} conv$2 = acc$conv$2;
  init flat$7$simp$4@{Bool} = True@{Bool};
  init flat$7$simp$5@{Error} = ExceptTombstone@{Error};
  init flat$7$simp$6@{Map DateTime Int} = Map []@{Map DateTime Int};
  foreach (flat$8 in 0@{Int}..Map_length#@{DateTime, Buf ((Sum Error Int), DateTime)}
                        conv$2) {
    let flat$9 = unsafe_Map_index#@{DateTime, Buf ((Sum Error Int), DateTime)}
                 conv$2 flat$8;
    let flat$10 = fst#@{DateTime, Buf ((Sum Error Int), DateTime)} flat$9;
    let flat$11 = snd#@{DateTime, Buf ((Sum Error Int), DateTime)} flat$9;
    read@{Bool} flat$7$simp$7 = flat$7$simp$4;
    read@{Error} flat$7$simp$8 = flat$7$simp$5;
    read@{Map DateTime Int} flat$7$simp$9 = flat$7$simp$6;
    init flat$12$simp$10@{Bool} = False@{Bool};
    init flat$12$simp$11@{Error} = ExceptTombstone@{Error};
    init flat$12$simp$12@{Map DateTime Int} = Map []@{Map DateTime Int};
    if (flat$7$simp$7) {
      let flat$15 = Buf_read#@{((Sum Error Int), DateTime)}
                    flat$11;
      init flat$16$simp$14$simp$18$simp$20@{Bool} = True@{Bool};
      init flat$16$simp$14$simp$18$simp$21@{Error} = ExceptTombstone@{Error};
      init flat$16$simp$14$simp$18$simp$22@{Int} = 0@{Int};
      foreach (flat$25 in 0@{Int}..Array_length#@{((Sum Error Int), DateTime)}
                             flat$15) {
        read@{Bool} flat$16$simp$24$simp$28$simp$30 = flat$16$simp$14$simp$18$simp$20;
        read@{Error} flat$16$simp$24$simp$28$simp$31 = flat$16$simp$14$simp$18$simp$21;
        read@{Int} flat$16$simp$24$simp$28$simp$32 = flat$16$simp$14$simp$18$simp$22;
        let flat$26 = unsafe_Array_index#@{((Sum Error Int), DateTime)}
                      flat$15 flat$25;
        let v$inline$0$conv$13 = fst#@{(Sum Error Int), DateTime}
                                 flat$26;
        init flat$27$simp$33@{Bool} = False@{Bool};
        init flat$27$simp$34@{Error} = ExceptTombstone@{Error};
        init flat$27$simp$35@{Int} = 0@{Int};
        if (Sum_isRight#@{Error, Int}
            v$inline$0$conv$13) {
          let flat$29 = unsafe_Sum_right#@{Error, Int}
                        v$inline$0$conv$13;
          init flat$30$simp$36@{Bool} = False@{Bool};
          init flat$30$simp$37@{Error} = ExceptTombstone@{Error};
          init flat$30$simp$38@{Int} = 0@{Int};
          if (flat$16$simp$24$simp$28$simp$30) {
            let simp$118 = add#@{Int} flat$29
                           flat$16$simp$24$simp$28$simp$32;
            write flat$30$simp$36 = True@{Bool};
            write flat$30$simp$37 = ExceptTombstone@{Error};
            write flat$30$simp$38 = simp$118;
          } else {
            write flat$30$simp$36 = False@{Bool};
            write flat$30$simp$37 = flat$16$simp$24$simp$28$simp$31;
            write flat$30$simp$38 = 0@{Int};
          }
          read@{Bool} flat$30$simp$39 = flat$30$simp$36;
          read@{Error} flat$30$simp$40 = flat$30$simp$37;
          read@{Int} flat$30$simp$41 = flat$30$simp$38;
          write flat$27$simp$33 = flat$30$simp$39;
          write flat$27$simp$34 = flat$30$simp$40;
          write flat$27$simp$35 = flat$30$simp$41;
        } else {
          let flat$28 = unsafe_Sum_left#@{Error, Int}
                        v$inline$0$conv$13;
          write flat$27$simp$33 = False@{Bool};
          write flat$27$simp$34 = flat$28;
          write flat$27$simp$35 = 0@{Int};
        }
        read@{Bool} flat$27$simp$42 = flat$27$simp$33;
        read@{Error} flat$27$simp$43 = flat$27$simp$34;
        read@{Int} flat$27$simp$44 = flat$27$simp$35;
        write flat$16$simp$14$simp$18$simp$20 = flat$27$simp$42;
        write flat$16$simp$14$simp$18$simp$21 = flat$27$simp$43;
        write flat$16$simp$14$simp$18$simp$22 = flat$27$simp$44;
      }
      read@{Bool} flat$16$simp$46$simp$50$simp$52 = flat$16$simp$14$simp$18$simp$20;
      read@{Error} flat$16$simp$46$simp$50$simp$53 = flat$16$simp$14$simp$18$simp$21;
      read@{Int} flat$16$simp$46$simp$50$simp$54 = flat$16$simp$14$simp$18$simp$22;
      init flat$17$simp$55@{Bool} = False@{Bool};
      init flat$17$simp$56@{Error} = ExceptTombstone@{Error};
      init flat$17$simp$57@{Map DateTime Int} = Map []@{Map DateTime Int};
      if (flat$16$simp$46$simp$50$simp$52) {
        init flat$23@{Map DateTime Int} = flat$7$simp$9;
        let flat$20 = Map_lookup#@{DateTime, Int}
                      flat$7$simp$9 flat$10;
        if (Option_isSome# [Int]
            flat$20) {
          let flat$22 = unsafe_Option_get#@{Int}
                        flat$20;
          write flat$23 = Map_put#@{DateTime, Int}
                          flat$7$simp$9 flat$10 flat$22;
        } else {
          write flat$23 = Map_put#@{DateTime, Int}
                          flat$7$simp$9 flat$10
                          flat$16$simp$46$simp$50$simp$54;
        } 
        
        read@{Map DateTime Int} flat$24 = flat$23;
        write flat$17$simp$55 = True@{Bool};
        write flat$17$simp$56 = ExceptTombstone@{Error};
        write flat$17$simp$57 = flat$24;
      } else {
        write flat$17$simp$55 = False@{Bool};
        write flat$17$simp$56 = flat$16$simp$46$simp$50$simp$53;
        write flat$17$simp$57 = Map []@{Map DateTime Int};
      }
      read@{Bool} flat$17$simp$58 = flat$17$simp$55;
      read@{Error} flat$17$simp$59 = flat$17$simp$56;
      read@{Map DateTime Int} flat$17$simp$60 = flat$17$simp$57;
      write flat$12$simp$10 = flat$17$simp$58;
      write flat$12$simp$11 = flat$17$simp$59;
      write flat$12$simp$12 = flat$17$simp$60;
    } else {
      write flat$12$simp$10 = False@{Bool};
      write flat$12$simp$11 = flat$7$simp$8;
      write flat$12$simp$12 = Map []@{Map DateTime Int};
    }
    read@{Bool} flat$12$simp$61 = flat$12$simp$10;
    read@{Error} flat$12$simp$62 = flat$12$simp$11;
    read@{Map DateTime Int} flat$12$simp$63 = flat$12$simp$12;
    write flat$7$simp$4 = flat$12$simp$61;
    write flat$7$simp$5 = flat$12$simp$62;
    write flat$7$simp$6 = flat$12$simp$63;
  }
  read@{Bool} flat$7$simp$64 = flat$7$simp$4;
  read@{Error} flat$7$simp$65 = flat$7$simp$5;
  read@{Map DateTime Int} flat$7$simp$66 = flat$7$simp$6;
  output@{(Sum Error (Map DateTime Int))} repl (flat$7$simp$64@{Bool},
               flat$7$simp$65@{Error},
               flat$7$simp$66@{Map DateTime Int});
}

- Core evaluation:
[homer, [(1989-12-17,100)
        ,(1990-01-01,200)
        ,(1994-01-01,300)
        ,(1999-01-01,400)
        ,(2010-01-01,500)]
,marge, [(1989-12-17,30)]]

> > > 