welcome to iREPL
ok, loaded 10 functions from data/libs/prelude.icicle
ok, loaded test/cli/repl/data.psv, 8 rows
> -- Show everything
> ok, flatten is now on
ok, c is now on
ok, c evaluation now on
                   _________-----_____
        _____------           __      ----_
 ___----             ___------              \
    ----________        ----                 \
                -----__    |             _____)
                     __-                /     \
         _______-----    ___--          \    /)\
   ------_______      ---____            \__/  /
                -----__    \ --    _          /\
                       --__--__     \_____/   \_/\
                               ----|   /          |
                                   |  |___________|
                                   |  | ((_(_)| )_)
                                   |  \_((_(_)|/(_)
                                   \             (
                                    \_____________)
> > -- Oldest
> - Flattened:
gen$date = DATE
{
  init [Mutable] [Bool] acc$conv$7$simp$0 = False : Bool;
  init [Mutable] [Int] acc$conv$7$simp$1 = 0 : Int;
  load_resumable [Bool] acc$conv$7$simp$0;
  load_resumable [Int] acc$conv$7$simp$1;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    read [Mutable] [Bool] acc$conv$7$simp$2 = acc$conv$7$simp$0;
    read [Mutable] [Int] acc$conv$7$simp$3 = acc$conv$7$simp$1;
    if (acc$conv$7$simp$2) {
      write acc$conv$7$simp$0 = True : Bool;
      write acc$conv$7$simp$1 = acc$conv$7$simp$3;
    } else {
      write acc$conv$7$simp$0 = True : Bool;
      write acc$conv$7$simp$1 = elem$gen$fact;
    }
  }
  save_resumable [Bool] acc$conv$7$simp$0;
  save_resumable [Int] acc$conv$7$simp$1;
  read [Mutable] [Bool] conv$7$simp$4 = acc$conv$7$simp$0;
  read [Mutable] [Int] conv$7$simp$5 = acc$conv$7$simp$1;
  if (conv$7$simp$4) {
    output repl conv$7$simp$5;
  } 
   else {
    output repl Exception: Fold1, but there is no value : Int;
  } 
  
}

- C:
#include <stdbool.h>
#include <stdint.h>
#include <math.h>

typedef uint64_t iunit_t;
typedef uint64_t ibool_t;
typedef  int64_t iint_t;
typedef   double idouble_t;
typedef  int64_t idate_t;

typedef const char *ierror_t;

typedef struct {
    /* inputs */
    idate_t    gen_date;
    iint_t     new_count;
    idate_t   *new_date;
    iint_t    *new_fact;

    /* outputs */
    ierror_t   error;
    iint_t     repl;

    /* resumables */
    ibool_t    acc_conv_7_simp_0;
    iint_t     acc_conv_7_simp_1;
} icicle_state_t;

static const iunit_t iunit  = 0x1c1c13;
static const ibool_t ifalse = 0;
static const ibool_t itrue  = 1;

#define INLINE __attribute__((always_inline))

static idouble_t INLINE iint_extend   (iint_t    x)              { return x; }
static iint_t    INLINE iint_add      (iint_t    x, iint_t    y) { return x +  y; }
static iint_t    INLINE iint_sub      (iint_t    x, iint_t    y) { return x -  y; }
static iint_t    INLINE iint_mul      (iint_t    x, iint_t    y) { return x *  y; }
static ibool_t   INLINE iint_gt       (iint_t    x, iint_t    y) { return x >  y; }
static ibool_t   INLINE iint_ge       (iint_t    x, iint_t    y) { return x >= y; }
static ibool_t   INLINE iint_lt       (iint_t    x, iint_t    y) { return x <  y; }
static ibool_t   INLINE iint_le       (iint_t    x, iint_t    y) { return x <= y; }
static ibool_t   INLINE iint_eq       (iint_t    x, iint_t    y) { return x == y; }
static ibool_t   INLINE iint_ne       (iint_t    x, iint_t    y) { return x != y; }

static iint_t    INLINE idouble_trunc (idouble_t x)              { return (iint_t)x; }
static idouble_t INLINE idouble_add   (idouble_t x, idouble_t y) { return x + y; }
static idouble_t INLINE idouble_sub   (idouble_t x, idouble_t y) { return x - y; }
static idouble_t INLINE idouble_mul   (idouble_t x, idouble_t y) { return x * y; }
static idouble_t INLINE idouble_pow   (idouble_t x, idouble_t y) { return pow(x, y); }
static idouble_t INLINE idouble_div   (idouble_t x, idouble_t y) { return x / y; }
static idouble_t INLINE idouble_log   (idouble_t x)              { return log(x); }
static idouble_t INLINE idouble_exp   (idouble_t x)              { return exp(x); }
static ibool_t   INLINE idouble_gt    (idouble_t x, idouble_t y) { return x >  y; }
static ibool_t   INLINE idouble_ge    (idouble_t x, idouble_t y) { return x >= y; }
static ibool_t   INLINE idouble_lt    (idouble_t x, idouble_t y) { return x <  y; }
static ibool_t   INLINE idouble_le    (idouble_t x, idouble_t y) { return x <= y; }
static ibool_t   INLINE idouble_eq    (idouble_t x, idouble_t y) { return x == y; }
static ibool_t   INLINE idouble_ne    (idouble_t x, idouble_t y) { return x != y; }

static iint_t INLINE iint_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0xBAD1c3;
}

static idouble_t INLINE idouble_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0/0;
}

void compute(icicle_state_t *s)
{
    ibool_t    acc_conv_7_simp_0;
    iint_t     acc_conv_7_simp_1;
    ibool_t    acc_conv_7_simp_2;
    iint_t     acc_conv_7_simp_3;
    ibool_t    conv_7_simp_4;
    iint_t     conv_7_simp_5;

    acc_conv_7_simp_0                    = ifalse;
    acc_conv_7_simp_1                    = 0;
    acc_conv_7_simp_0                    = s->acc_conv_7_simp_0;
    acc_conv_7_simp_1                    = s->acc_conv_7_simp_1;
    
    const iint_t            new_count    = s->new_count;
    const idate_t    *const new_date     = s->new_date;
    const iint_t     *const new_fact     = s->new_fact;
    
    for (iint_t i = 0; i < new_count; i++) {
        idate_t    elem_gen_date         = new_date[i];
        iint_t     elem_gen_fact         = new_fact[i];
        acc_conv_7_simp_2                = acc_conv_7_simp_0;
        acc_conv_7_simp_3                = acc_conv_7_simp_1;
        
        if (acc_conv_7_simp_2) {
            acc_conv_7_simp_0            = itrue;
            acc_conv_7_simp_1            = acc_conv_7_simp_3;
        } else {
            acc_conv_7_simp_0            = itrue;
            acc_conv_7_simp_1            = elem_gen_fact;
        }
        
    }
    
    s->acc_conv_7_simp_0                 = acc_conv_7_simp_0;
    s->acc_conv_7_simp_1                 = acc_conv_7_simp_1;
    conv_7_simp_4                        = acc_conv_7_simp_0;
    conv_7_simp_5                        = acc_conv_7_simp_1;
    
    if (conv_7_simp_4) {
        s->repl                          = conv_7_simp_5;
    } else {
        s->repl                          = iint_err (s, "ExceptFold1NoValue");
    }
    
}

- C evaluation:
[(homer,100),(marge,0)]

- Core evaluation:
[homer, 100,marge, 0]

> > -- Filtering works
> - Flattened:
gen$date = DATE
{
  init [Mutable] [Int] acc$c$conv$5 = 0 : Int;
  load_resumable [Int] acc$c$conv$5;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    if (gt# [Int] elem$gen$fact
        (300 : Int)) {
      read [Mutable] [Int] acc$c$conv$5 = acc$c$conv$5;
      write acc$c$conv$5 = add# [Int]
                           acc$c$conv$5 (1 : Int);
    }
  } 
  
  save_resumable [Int] acc$c$conv$5;
  read [Mutable] [Int] c$conv$5 = acc$c$conv$5;
  output repl c$conv$5;
}

- C:
#include <stdbool.h>
#include <stdint.h>
#include <math.h>

typedef uint64_t iunit_t;
typedef uint64_t ibool_t;
typedef  int64_t iint_t;
typedef   double idouble_t;
typedef  int64_t idate_t;

typedef const char *ierror_t;

typedef struct {
    /* inputs */
    idate_t    gen_date;
    iint_t     new_count;
    idate_t   *new_date;
    iint_t    *new_fact;

    /* outputs */
    ierror_t   error;
    iint_t     repl;

    /* resumables */
    iint_t     acc_c_conv_5;
} icicle_state_t;

static const iunit_t iunit  = 0x1c1c13;
static const ibool_t ifalse = 0;
static const ibool_t itrue  = 1;

#define INLINE __attribute__((always_inline))

static idouble_t INLINE iint_extend   (iint_t    x)              { return x; }
static iint_t    INLINE iint_add      (iint_t    x, iint_t    y) { return x +  y; }
static iint_t    INLINE iint_sub      (iint_t    x, iint_t    y) { return x -  y; }
static iint_t    INLINE iint_mul      (iint_t    x, iint_t    y) { return x *  y; }
static ibool_t   INLINE iint_gt       (iint_t    x, iint_t    y) { return x >  y; }
static ibool_t   INLINE iint_ge       (iint_t    x, iint_t    y) { return x >= y; }
static ibool_t   INLINE iint_lt       (iint_t    x, iint_t    y) { return x <  y; }
static ibool_t   INLINE iint_le       (iint_t    x, iint_t    y) { return x <= y; }
static ibool_t   INLINE iint_eq       (iint_t    x, iint_t    y) { return x == y; }
static ibool_t   INLINE iint_ne       (iint_t    x, iint_t    y) { return x != y; }

static iint_t    INLINE idouble_trunc (idouble_t x)              { return (iint_t)x; }
static idouble_t INLINE idouble_add   (idouble_t x, idouble_t y) { return x + y; }
static idouble_t INLINE idouble_sub   (idouble_t x, idouble_t y) { return x - y; }
static idouble_t INLINE idouble_mul   (idouble_t x, idouble_t y) { return x * y; }
static idouble_t INLINE idouble_pow   (idouble_t x, idouble_t y) { return pow(x, y); }
static idouble_t INLINE idouble_div   (idouble_t x, idouble_t y) { return x / y; }
static idouble_t INLINE idouble_log   (idouble_t x)              { return log(x); }
static idouble_t INLINE idouble_exp   (idouble_t x)              { return exp(x); }
static ibool_t   INLINE idouble_gt    (idouble_t x, idouble_t y) { return x >  y; }
static ibool_t   INLINE idouble_ge    (idouble_t x, idouble_t y) { return x >= y; }
static ibool_t   INLINE idouble_lt    (idouble_t x, idouble_t y) { return x <  y; }
static ibool_t   INLINE idouble_le    (idouble_t x, idouble_t y) { return x <= y; }
static ibool_t   INLINE idouble_eq    (idouble_t x, idouble_t y) { return x == y; }
static ibool_t   INLINE idouble_ne    (idouble_t x, idouble_t y) { return x != y; }

static iint_t INLINE iint_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0xBAD1c3;
}

static idouble_t INLINE idouble_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0/0;
}

void compute(icicle_state_t *s)
{
    iint_t     acc_c_conv_5;
    iint_t     c_conv_5;

    acc_c_conv_5                         = 0;
    acc_c_conv_5                         = s->acc_c_conv_5;
    
    const iint_t            new_count    = s->new_count;
    const idate_t    *const new_date     = s->new_date;
    const iint_t     *const new_fact     = s->new_fact;
    
    for (iint_t i = 0; i < new_count; i++) {
        idate_t    elem_gen_date         = new_date[i];
        iint_t     elem_gen_fact         = new_fact[i];
        
        if (iint_gt (elem_gen_fact, 300)) {
            acc_c_conv_5                 = acc_c_conv_5;
            acc_c_conv_5                 = iint_add (acc_c_conv_5, 1);
        }
        
    }
    
    s->acc_c_conv_5                      = acc_c_conv_5;
    c_conv_5                             = acc_c_conv_5;
    s->repl                              = c_conv_5;
}

- C evaluation:
[(homer,2),(marge,0)]

- Core evaluation:
[homer, 2,marge, 0]

> > -- An interesting expression
> - Flattened:
gen$date = DATE
{
  init [Mutable] [Double] acc$s$conv$9 = 0.0 : Double;
  init [Mutable] [Double] acc$s$conv$14 = 0.0 : Double;
  init [Mutable] [Double] acc$c$conv$16 = 0.0 : Double;
  init [Mutable] [Double] acc$c$conv$21 = 0.0 : Double;
  init [Mutable] [Double] acc$c$conv$23 = 0.0 : Double;
  init [Mutable] [Double] acc$s$conv$39 = 0.0 : Double;
  init [Mutable] [Double] acc$s$conv$44 = 0.0 : Double;
  init [Mutable] [Double] acc$c$conv$46 = 0.0 : Double;
  init [Mutable] [Double] acc$c$conv$51 = 0.0 : Double;
  init [Mutable] [Double] acc$c$conv$53 = 0.0 : Double;
  load_resumable [Double] acc$s$conv$9;
  load_resumable [Double] acc$s$conv$14;
  load_resumable [Double] acc$c$conv$16;
  load_resumable [Double] acc$c$conv$21;
  load_resumable [Double] acc$c$conv$23;
  load_resumable [Double] acc$s$conv$39;
  load_resumable [Double] acc$s$conv$44;
  load_resumable [Double] acc$c$conv$46;
  load_resumable [Double] acc$c$conv$51;
  load_resumable [Double] acc$c$conv$53;
  for_facts (elem$gen$fact : Int, elem$gen$date : Date) in new {
    let anf$35 = doubleOfInt#
                 elem$gen$fact;
    read [Mutable] [Double] acc$c$conv$16 = acc$c$conv$16;
    write acc$c$conv$16 = add# [Double]
                          acc$c$conv$16 (1.0 : Double);
    read [Mutable] [Double] acc$c$conv$21 = acc$c$conv$21;
    write acc$c$conv$21 = add# [Double]
                          acc$c$conv$21 (1.0 : Double);
    read [Mutable] [Double] acc$c$conv$23 = acc$c$conv$23;
    write acc$c$conv$23 = add# [Double]
                          acc$c$conv$23 (1.0 : Double);
    read [Mutable] [Double] acc$s$conv$9 = acc$s$conv$9;
    write acc$s$conv$9 = add# [Double]
                         anf$35 acc$s$conv$9;
    let anf$45 = mul# [Double]
                 anf$35 anf$35;
    read [Mutable] [Double] acc$s$conv$14 = acc$s$conv$14;
    write acc$s$conv$14 = add# [Double]
                          anf$45 acc$s$conv$14;
    if (lt# [Int] elem$gen$fact
        (300 : Int)) {
      read [Mutable] [Double] acc$c$conv$46 = acc$c$conv$46;
      write acc$c$conv$46 = add# [Double]
                            acc$c$conv$46 (1.0 : Double);
      read [Mutable] [Double] acc$c$conv$51 = acc$c$conv$51;
      write acc$c$conv$51 = add# [Double]
                            acc$c$conv$51 (1.0 : Double);
      read [Mutable] [Double] acc$c$conv$53 = acc$c$conv$53;
      write acc$c$conv$53 = add# [Double]
                            acc$c$conv$53 (1.0 : Double);
      read [Mutable] [Double] acc$s$conv$39 = acc$s$conv$39;
      write acc$s$conv$39 = add# [Double]
                            anf$35 acc$s$conv$39;
      read [Mutable] [Double] acc$s$conv$44 = acc$s$conv$44;
      write acc$s$conv$44 = add# [Double]
                            anf$45 acc$s$conv$44;
    }
  }
  save_resumable [Double] acc$s$conv$9;
  save_resumable [Double] acc$s$conv$14;
  save_resumable [Double] acc$c$conv$16;
  save_resumable [Double] acc$c$conv$21;
  save_resumable [Double] acc$c$conv$23;
  save_resumable [Double] acc$s$conv$39;
  save_resumable [Double] acc$s$conv$44;
  save_resumable [Double] acc$c$conv$46;
  save_resumable [Double] acc$c$conv$51;
  save_resumable [Double] acc$c$conv$53;
  read [Mutable] [Double] s$conv$9 = acc$s$conv$9;
  read [Mutable] [Double] s$conv$14 = acc$s$conv$14;
  read [Mutable] [Double] c$conv$16 = acc$c$conv$16;
  read [Mutable] [Double] c$conv$21 = acc$c$conv$21;
  read [Mutable] [Double] c$conv$23 = acc$c$conv$23;
  read [Mutable] [Double] s$conv$39 = acc$s$conv$39;
  read [Mutable] [Double] s$conv$44 = acc$s$conv$44;
  read [Mutable] [Double] c$conv$46 = acc$c$conv$46;
  read [Mutable] [Double] c$conv$51 = acc$c$conv$51;
  read [Mutable] [Double] c$conv$53 = acc$c$conv$53;
  let conv$17 = mul# [Double]
                s$conv$14 c$conv$16;
  let conv$18 = mul# [Double]
                s$conv$9 s$conv$9;
  let conv$19 = sub# [Double]
                conv$17 conv$18;
  let conv$25 = sub# [Double]
                c$conv$23 (1.0 : Double);
  let conv$26 = mul# [Double]
                c$conv$21 conv$25;
  let conv$27 = div# conv$19
                conv$26;
  let conv$29 = pow# [Double]
                conv$27 (0.5 : Double);
  let conv$47 = mul# [Double]
                s$conv$44 c$conv$46;
  let conv$48 = mul# [Double]
                s$conv$39 s$conv$39;
  let conv$49 = sub# [Double]
                conv$47 conv$48;
  let conv$55 = sub# [Double]
                c$conv$53 (1.0 : Double);
  let conv$56 = mul# [Double]
                c$conv$51 conv$55;
  let conv$57 = div# conv$49
                conv$56;
  let conv$59 = pow# [Double]
                conv$57 (0.5 : Double);
  let conv$60 = mul# [Double]
                conv$29 conv$59;
  output repl conv$60;
}

- C:
#include <stdbool.h>
#include <stdint.h>
#include <math.h>

typedef uint64_t iunit_t;
typedef uint64_t ibool_t;
typedef  int64_t iint_t;
typedef   double idouble_t;
typedef  int64_t idate_t;

typedef const char *ierror_t;

typedef struct {
    /* inputs */
    idate_t    gen_date;
    iint_t     new_count;
    idate_t   *new_date;
    iint_t    *new_fact;

    /* outputs */
    ierror_t   error;
    idouble_t  repl;

    /* resumables */
    idouble_t  acc_c_conv_16;
    idouble_t  acc_c_conv_21;
    idouble_t  acc_c_conv_23;
    idouble_t  acc_c_conv_46;
    idouble_t  acc_c_conv_51;
    idouble_t  acc_c_conv_53;
    idouble_t  acc_s_conv_14;
    idouble_t  acc_s_conv_39;
    idouble_t  acc_s_conv_44;
    idouble_t  acc_s_conv_9;
} icicle_state_t;

static const iunit_t iunit  = 0x1c1c13;
static const ibool_t ifalse = 0;
static const ibool_t itrue  = 1;

#define INLINE __attribute__((always_inline))

static idouble_t INLINE iint_extend   (iint_t    x)              { return x; }
static iint_t    INLINE iint_add      (iint_t    x, iint_t    y) { return x +  y; }
static iint_t    INLINE iint_sub      (iint_t    x, iint_t    y) { return x -  y; }
static iint_t    INLINE iint_mul      (iint_t    x, iint_t    y) { return x *  y; }
static ibool_t   INLINE iint_gt       (iint_t    x, iint_t    y) { return x >  y; }
static ibool_t   INLINE iint_ge       (iint_t    x, iint_t    y) { return x >= y; }
static ibool_t   INLINE iint_lt       (iint_t    x, iint_t    y) { return x <  y; }
static ibool_t   INLINE iint_le       (iint_t    x, iint_t    y) { return x <= y; }
static ibool_t   INLINE iint_eq       (iint_t    x, iint_t    y) { return x == y; }
static ibool_t   INLINE iint_ne       (iint_t    x, iint_t    y) { return x != y; }

static iint_t    INLINE idouble_trunc (idouble_t x)              { return (iint_t)x; }
static idouble_t INLINE idouble_add   (idouble_t x, idouble_t y) { return x + y; }
static idouble_t INLINE idouble_sub   (idouble_t x, idouble_t y) { return x - y; }
static idouble_t INLINE idouble_mul   (idouble_t x, idouble_t y) { return x * y; }
static idouble_t INLINE idouble_pow   (idouble_t x, idouble_t y) { return pow(x, y); }
static idouble_t INLINE idouble_div   (idouble_t x, idouble_t y) { return x / y; }
static idouble_t INLINE idouble_log   (idouble_t x)              { return log(x); }
static idouble_t INLINE idouble_exp   (idouble_t x)              { return exp(x); }
static ibool_t   INLINE idouble_gt    (idouble_t x, idouble_t y) { return x >  y; }
static ibool_t   INLINE idouble_ge    (idouble_t x, idouble_t y) { return x >= y; }
static ibool_t   INLINE idouble_lt    (idouble_t x, idouble_t y) { return x <  y; }
static ibool_t   INLINE idouble_le    (idouble_t x, idouble_t y) { return x <= y; }
static ibool_t   INLINE idouble_eq    (idouble_t x, idouble_t y) { return x == y; }
static ibool_t   INLINE idouble_ne    (idouble_t x, idouble_t y) { return x != y; }

static iint_t INLINE iint_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0xBAD1c3;
}

static idouble_t INLINE idouble_err (icicle_state_t *s, ierror_t error)  {
    s->error = error;
    return 0/0;
}

void compute(icicle_state_t *s)
{
    idouble_t  acc_c_conv_16;
    idouble_t  acc_c_conv_21;
    idouble_t  acc_c_conv_23;
    idouble_t  acc_c_conv_46;
    idouble_t  acc_c_conv_51;
    idouble_t  acc_c_conv_53;
    idouble_t  acc_s_conv_14;
    idouble_t  acc_s_conv_39;
    idouble_t  acc_s_conv_44;
    idouble_t  acc_s_conv_9;
    idouble_t  c_conv_16;
    idouble_t  c_conv_21;
    idouble_t  c_conv_23;
    idouble_t  c_conv_46;
    idouble_t  c_conv_51;
    idouble_t  c_conv_53;
    idouble_t  s_conv_14;
    idouble_t  s_conv_39;
    idouble_t  s_conv_44;
    idouble_t  s_conv_9;

    acc_s_conv_9                         = 0.0;
    acc_s_conv_14                        = 0.0;
    acc_c_conv_16                        = 0.0;
    acc_c_conv_21                        = 0.0;
    acc_c_conv_23                        = 0.0;
    acc_s_conv_39                        = 0.0;
    acc_s_conv_44                        = 0.0;
    acc_c_conv_46                        = 0.0;
    acc_c_conv_51                        = 0.0;
    acc_c_conv_53                        = 0.0;
    acc_s_conv_9                         = s->acc_s_conv_9;
    acc_s_conv_14                        = s->acc_s_conv_14;
    acc_c_conv_16                        = s->acc_c_conv_16;
    acc_c_conv_21                        = s->acc_c_conv_21;
    acc_c_conv_23                        = s->acc_c_conv_23;
    acc_s_conv_39                        = s->acc_s_conv_39;
    acc_s_conv_44                        = s->acc_s_conv_44;
    acc_c_conv_46                        = s->acc_c_conv_46;
    acc_c_conv_51                        = s->acc_c_conv_51;
    acc_c_conv_53                        = s->acc_c_conv_53;
    
    const iint_t            new_count    = s->new_count;
    const idate_t    *const new_date     = s->new_date;
    const iint_t     *const new_fact     = s->new_fact;
    
    for (iint_t i = 0; i < new_count; i++) {
        idate_t    elem_gen_date         = new_date[i];
        iint_t     elem_gen_fact         = new_fact[i];
        idouble_t  anf_35                = iint_extend (elem_gen_fact);
        acc_c_conv_16                    = acc_c_conv_16;
        acc_c_conv_16                    = idouble_add (acc_c_conv_16, 1.0);
        acc_c_conv_21                    = acc_c_conv_21;
        acc_c_conv_21                    = idouble_add (acc_c_conv_21, 1.0);
        acc_c_conv_23                    = acc_c_conv_23;
        acc_c_conv_23                    = idouble_add (acc_c_conv_23, 1.0);
        acc_s_conv_9                     = acc_s_conv_9;
        acc_s_conv_9                     = idouble_add (anf_35, acc_s_conv_9);
        idouble_t  anf_45                = idouble_mul (anf_35, anf_35);
        acc_s_conv_14                    = acc_s_conv_14;
        acc_s_conv_14                    = idouble_add (anf_45, acc_s_conv_14);
        
        if (iint_lt (elem_gen_fact, 300)) {
            acc_c_conv_46                = acc_c_conv_46;
            acc_c_conv_46                = idouble_add (acc_c_conv_46, 1.0);
            acc_c_conv_51                = acc_c_conv_51;
            acc_c_conv_51                = idouble_add (acc_c_conv_51, 1.0);
            acc_c_conv_53                = acc_c_conv_53;
            acc_c_conv_53                = idouble_add (acc_c_conv_53, 1.0);
            acc_s_conv_39                = acc_s_conv_39;
            acc_s_conv_39                = idouble_add (anf_35, acc_s_conv_39);
            acc_s_conv_44                = acc_s_conv_44;
            acc_s_conv_44                = idouble_add (anf_45, acc_s_conv_44);
        }
        
    }
    
    s->acc_s_conv_9                      = acc_s_conv_9;
    s->acc_s_conv_14                     = acc_s_conv_14;
    s->acc_c_conv_16                     = acc_c_conv_16;
    s->acc_c_conv_21                     = acc_c_conv_21;
    s->acc_c_conv_23                     = acc_c_conv_23;
    s->acc_s_conv_39                     = acc_s_conv_39;
    s->acc_s_conv_44                     = acc_s_conv_44;
    s->acc_c_conv_46                     = acc_c_conv_46;
    s->acc_c_conv_51                     = acc_c_conv_51;
    s->acc_c_conv_53                     = acc_c_conv_53;
    s_conv_9                             = acc_s_conv_9;
    s_conv_14                            = acc_s_conv_14;
    c_conv_16                            = acc_c_conv_16;
    c_conv_21                            = acc_c_conv_21;
    c_conv_23                            = acc_c_conv_23;
    s_conv_39                            = acc_s_conv_39;
    s_conv_44                            = acc_s_conv_44;
    c_conv_46                            = acc_c_conv_46;
    c_conv_51                            = acc_c_conv_51;
    c_conv_53                            = acc_c_conv_53;
    idouble_t  conv_17                   = idouble_mul (s_conv_14, c_conv_16);
    idouble_t  conv_18                   = idouble_mul (s_conv_9, s_conv_9);
    idouble_t  conv_19                   = idouble_sub (conv_17, conv_18);
    idouble_t  conv_25                   = idouble_sub (c_conv_23, 1.0);
    idouble_t  conv_26                   = idouble_mul (c_conv_21, conv_25);
    idouble_t  conv_27                   = idouble_div (conv_19, conv_26);
    idouble_t  conv_29                   = idouble_pow (conv_27, 0.5);
    idouble_t  conv_47                   = idouble_mul (s_conv_44, c_conv_46);
    idouble_t  conv_48                   = idouble_mul (s_conv_39, s_conv_39);
    idouble_t  conv_49                   = idouble_sub (conv_47, conv_48);
    idouble_t  conv_55                   = idouble_sub (c_conv_53, 1.0);
    idouble_t  conv_56                   = idouble_mul (c_conv_51, conv_55);
    idouble_t  conv_57                   = idouble_div (conv_49, conv_56);
    idouble_t  conv_59                   = idouble_pow (conv_57, 0.5);
    idouble_t  conv_60                   = idouble_mul (conv_29, conv_59);
    s->repl                              = conv_60;
}

- C evaluation:
[(homer,11180.33988749895)
,(marge,100.0)]

- Core evaluation:
[homer, 11180.33988749895
,marge, 100.0]

> 